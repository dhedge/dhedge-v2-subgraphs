// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class DAOAddressSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DAOAddressSet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DAOAddressSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DAOAddressSet", id.toString(), this);
    }
  }

  static load(id: string): DAOAddressSet | null {
    return changetype<DAOAddressSet | null>(store.get("DAOAddressSet", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get daoAddress(): Bytes {
    let value = this.get("daoAddress");
    return value!.toBytes();
  }

  set daoAddress(value: Bytes) {
    this.set("daoAddress", Value.fromBytes(value));
  }
}

export class DaoFeeSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DaoFeeSet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DaoFeeSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DaoFeeSet", id.toString(), this);
    }
  }

  static load(id: string): DaoFeeSet | null {
    return changetype<DaoFeeSet | null>(store.get("DaoFeeSet", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get numerator(): BigInt {
    let value = this.get("numerator");
    return value!.toBigInt();
  }

  set numerator(value: BigInt) {
    this.set("numerator", Value.fromBigInt(value));
  }

  get denominator(): BigInt {
    let value = this.get("denominator");
    return value!.toBigInt();
  }

  set denominator(value: BigInt) {
    this.set("denominator", Value.fromBigInt(value));
  }
}

export class ExitCooldownSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExitCooldownSet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExitCooldownSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExitCooldownSet", id.toString(), this);
    }
  }

  static load(id: string): ExitCooldownSet | null {
    return changetype<ExitCooldownSet | null>(store.get("ExitCooldownSet", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get cooldown(): BigInt {
    let value = this.get("cooldown");
    return value!.toBigInt();
  }

  set cooldown(value: BigInt) {
    this.set("cooldown", Value.fromBigInt(value));
  }
}

export class ExitFeeSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExitFeeSet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExitFeeSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExitFeeSet", id.toString(), this);
    }
  }

  static load(id: string): ExitFeeSet | null {
    return changetype<ExitFeeSet | null>(store.get("ExitFeeSet", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get numerator(): BigInt {
    let value = this.get("numerator");
    return value!.toBigInt();
  }

  set numerator(value: BigInt) {
    this.set("numerator", Value.fromBigInt(value));
  }

  get denominator(): BigInt {
    let value = this.get("denominator");
    return value!.toBigInt();
  }

  set denominator(value: BigInt) {
    this.set("denominator", Value.fromBigInt(value));
  }
}

export class FundCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FundCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type FundCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FundCreated", id.toString(), this);
    }
  }

  static load(id: string): FundCreated | null {
    return changetype<FundCreated | null>(store.get("FundCreated", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fundAddress(): Bytes {
    let value = this.get("fundAddress");
    return value!.toBytes();
  }

  set fundAddress(value: Bytes) {
    this.set("fundAddress", Value.fromBytes(value));
  }

  get isPoolPrivate(): boolean {
    let value = this.get("isPoolPrivate");
    return value!.toBoolean();
  }

  set isPoolPrivate(value: boolean) {
    this.set("isPoolPrivate", Value.fromBoolean(value));
  }

  get fundName(): string {
    let value = this.get("fundName");
    return value!.toString();
  }

  set fundName(value: string) {
    this.set("fundName", Value.fromString(value));
  }

  get managerName(): string {
    let value = this.get("managerName");
    return value!.toString();
  }

  set managerName(value: string) {
    this.set("managerName", Value.fromString(value));
  }

  get manager(): Bytes {
    let value = this.get("manager");
    return value!.toBytes();
  }

  set manager(value: Bytes) {
    this.set("manager", Value.fromBytes(value));
  }

  get time(): BigInt {
    let value = this.get("time");
    return value!.toBigInt();
  }

  set time(value: BigInt) {
    this.set("time", Value.fromBigInt(value));
  }

  get performanceFeeNumerator(): BigInt {
    let value = this.get("performanceFeeNumerator");
    return value!.toBigInt();
  }

  set performanceFeeNumerator(value: BigInt) {
    this.set("performanceFeeNumerator", Value.fromBigInt(value));
  }

  get managerFeeNumerator(): BigInt {
    let value = this.get("managerFeeNumerator");
    return value!.toBigInt();
  }

  set managerFeeNumerator(value: BigInt) {
    this.set("managerFeeNumerator", Value.fromBigInt(value));
  }

  get managerFeeDenominator(): BigInt {
    let value = this.get("managerFeeDenominator");
    return value!.toBigInt();
  }

  set managerFeeDenominator(value: BigInt) {
    this.set("managerFeeDenominator", Value.fromBigInt(value));
  }

  get uniqueManager(): string {
    let value = this.get("uniqueManager");
    return value!.toString();
  }

  set uniqueManager(value: string) {
    this.set("uniqueManager", Value.fromString(value));
  }
}

export class GovernanceAddressSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GovernanceAddressSet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type GovernanceAddressSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GovernanceAddressSet", id.toString(), this);
    }
  }

  static load(id: string): GovernanceAddressSet | null {
    return changetype<GovernanceAddressSet | null>(
      store.get("GovernanceAddressSet", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get governanceAddress(): Bytes {
    let value = this.get("governanceAddress");
    return value!.toBytes();
  }

  set governanceAddress(value: Bytes) {
    this.set("governanceAddress", Value.fromBytes(value));
  }
}

export class LogUpgrade extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LogUpgrade entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LogUpgrade must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LogUpgrade", id.toString(), this);
    }
  }

  static load(id: string): LogUpgrade | null {
    return changetype<LogUpgrade | null>(store.get("LogUpgrade", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get manager(): Bytes {
    let value = this.get("manager");
    return value!.toBytes();
  }

  set manager(value: Bytes) {
    this.set("manager", Value.fromBytes(value));
  }

  get pool(): Bytes {
    let value = this.get("pool");
    return value!.toBytes();
  }

  set pool(value: Bytes) {
    this.set("pool", Value.fromBytes(value));
  }
}

export class MaximumSupportedAssetCountSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save MaximumSupportedAssetCountSet entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type MaximumSupportedAssetCountSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MaximumSupportedAssetCountSet", id.toString(), this);
    }
  }

  static load(id: string): MaximumSupportedAssetCountSet | null {
    return changetype<MaximumSupportedAssetCountSet | null>(
      store.get("MaximumSupportedAssetCountSet", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get count(): BigInt {
    let value = this.get("count");
    return value!.toBigInt();
  }

  set count(value: BigInt) {
    this.set("count", Value.fromBigInt(value));
  }
}

export class OwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OwnershipTransferred entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OwnershipTransferred must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): OwnershipTransferred | null {
    return changetype<OwnershipTransferred | null>(
      store.get("OwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Paused extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Paused entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Paused must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Paused", id.toString(), this);
    }
  }

  static load(id: string): Paused | null {
    return changetype<Paused | null>(store.get("Paused", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }
}

export class PoolPerformanceAddressSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save PoolPerformanceAddressSet entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PoolPerformanceAddressSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PoolPerformanceAddressSet", id.toString(), this);
    }
  }

  static load(id: string): PoolPerformanceAddressSet | null {
    return changetype<PoolPerformanceAddressSet | null>(
      store.get("PoolPerformanceAddressSet", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get poolPerformanceAddress(): Bytes {
    let value = this.get("poolPerformanceAddress");
    return value!.toBytes();
  }

  set poolPerformanceAddress(value: Bytes) {
    this.set("poolPerformanceAddress", Value.fromBytes(value));
  }
}

export class ProxyCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProxyCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProxyCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ProxyCreated", id.toString(), this);
    }
  }

  static load(id: string): ProxyCreated | null {
    return changetype<ProxyCreated | null>(store.get("ProxyCreated", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proxy(): Bytes {
    let value = this.get("proxy");
    return value!.toBytes();
  }

  set proxy(value: Bytes) {
    this.set("proxy", Value.fromBytes(value));
  }
}

export class SetAssetHandler extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SetAssetHandler entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SetAssetHandler must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SetAssetHandler", id.toString(), this);
    }
  }

  static load(id: string): SetAssetHandler | null {
    return changetype<SetAssetHandler | null>(store.get("SetAssetHandler", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get assetHandler(): Bytes {
    let value = this.get("assetHandler");
    return value!.toBytes();
  }

  set assetHandler(value: Bytes) {
    this.set("assetHandler", Value.fromBytes(value));
  }
}

export class SetManagerFeeNumeratorChangeDelay extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save SetManagerFeeNumeratorChangeDelay entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SetManagerFeeNumeratorChangeDelay must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SetManagerFeeNumeratorChangeDelay", id.toString(), this);
    }
  }

  static load(id: string): SetManagerFeeNumeratorChangeDelay | null {
    return changetype<SetManagerFeeNumeratorChangeDelay | null>(
      store.get("SetManagerFeeNumeratorChangeDelay", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get delay(): BigInt {
    let value = this.get("delay");
    return value!.toBigInt();
  }

  set delay(value: BigInt) {
    this.set("delay", Value.fromBigInt(value));
  }
}

export class SetMaximumManagerFee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SetMaximumManagerFee entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SetMaximumManagerFee must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SetMaximumManagerFee", id.toString(), this);
    }
  }

  static load(id: string): SetMaximumManagerFee | null {
    return changetype<SetMaximumManagerFee | null>(
      store.get("SetMaximumManagerFee", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get numerator(): BigInt {
    let value = this.get("numerator");
    return value!.toBigInt();
  }

  set numerator(value: BigInt) {
    this.set("numerator", Value.fromBigInt(value));
  }

  get denominator(): BigInt {
    let value = this.get("denominator");
    return value!.toBigInt();
  }

  set denominator(value: BigInt) {
    this.set("denominator", Value.fromBigInt(value));
  }
}

export class SetMaximumManagerFeeNumeratorChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save SetMaximumManagerFeeNumeratorChange entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SetMaximumManagerFeeNumeratorChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SetMaximumManagerFeeNumeratorChange", id.toString(), this);
    }
  }

  static load(id: string): SetMaximumManagerFeeNumeratorChange | null {
    return changetype<SetMaximumManagerFeeNumeratorChange | null>(
      store.get("SetMaximumManagerFeeNumeratorChange", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class SetPoolManagerFee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SetPoolManagerFee entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SetPoolManagerFee must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SetPoolManagerFee", id.toString(), this);
    }
  }

  static load(id: string): SetPoolManagerFee | null {
    return changetype<SetPoolManagerFee | null>(
      store.get("SetPoolManagerFee", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get numerator(): BigInt {
    let value = this.get("numerator");
    return value!.toBigInt();
  }

  set numerator(value: BigInt) {
    this.set("numerator", Value.fromBigInt(value));
  }

  get denominator(): BigInt {
    let value = this.get("denominator");
    return value!.toBigInt();
  }

  set denominator(value: BigInt) {
    this.set("denominator", Value.fromBigInt(value));
  }
}

export class SetPoolStorageVersion extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save SetPoolStorageVersion entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SetPoolStorageVersion must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SetPoolStorageVersion", id.toString(), this);
    }
  }

  static load(id: string): SetPoolStorageVersion | null {
    return changetype<SetPoolStorageVersion | null>(
      store.get("SetPoolStorageVersion", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get poolStorageVersion(): BigInt {
    let value = this.get("poolStorageVersion");
    return value!.toBigInt();
  }

  set poolStorageVersion(value: BigInt) {
    this.set("poolStorageVersion", Value.fromBigInt(value));
  }
}

export class Unpaused extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Unpaused entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Unpaused must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Unpaused", id.toString(), this);
    }
  }

  static load(id: string): Unpaused | null {
    return changetype<Unpaused | null>(store.get("Unpaused", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }
}

export class Approval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Approval entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Approval must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Approval", id.toString(), this);
    }
  }

  static load(id: string): Approval | null {
    return changetype<Approval | null>(store.get("Approval", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value!.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class Deposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Deposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Deposit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Deposit", id.toString(), this);
    }
  }

  static load(id: string): Deposit | null {
    return changetype<Deposit | null>(store.get("Deposit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fundAddress(): Bytes {
    let value = this.get("fundAddress");
    return value!.toBytes();
  }

  set fundAddress(value: Bytes) {
    this.set("fundAddress", Value.fromBytes(value));
  }

  get investor(): Bytes {
    let value = this.get("investor");
    return value!.toBytes();
  }

  set investor(value: Bytes) {
    this.set("investor", Value.fromBytes(value));
  }

  get assetDeposited(): Bytes {
    let value = this.get("assetDeposited");
    return value!.toBytes();
  }

  set assetDeposited(value: Bytes) {
    this.set("assetDeposited", Value.fromBytes(value));
  }

  get valueDeposited(): BigInt {
    let value = this.get("valueDeposited");
    return value!.toBigInt();
  }

  set valueDeposited(value: BigInt) {
    this.set("valueDeposited", Value.fromBigInt(value));
  }

  get fundTokensReceived(): BigInt {
    let value = this.get("fundTokensReceived");
    return value!.toBigInt();
  }

  set fundTokensReceived(value: BigInt) {
    this.set("fundTokensReceived", Value.fromBigInt(value));
  }

  get totalInvestorFundTokens(): BigInt {
    let value = this.get("totalInvestorFundTokens");
    return value!.toBigInt();
  }

  set totalInvestorFundTokens(value: BigInt) {
    this.set("totalInvestorFundTokens", Value.fromBigInt(value));
  }

  get fundValue(): BigInt {
    let value = this.get("fundValue");
    return value!.toBigInt();
  }

  set fundValue(value: BigInt) {
    this.set("fundValue", Value.fromBigInt(value));
  }

  get time(): BigInt {
    let value = this.get("time");
    return value!.toBigInt();
  }

  set time(value: BigInt) {
    this.set("time", Value.fromBigInt(value));
  }

  get blockNumber(): i32 {
    let value = this.get("blockNumber");
    return value!.toI32();
  }

  set blockNumber(value: i32) {
    this.set("blockNumber", Value.fromI32(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get totalSupply(): BigDecimal {
    let value = this.get("totalSupply");
    return value!.toBigDecimal();
  }

  set totalSupply(value: BigDecimal) {
    this.set("totalSupply", Value.fromBigDecimal(value));
  }

  get poolName(): string {
    let value = this.get("poolName");
    return value!.toString();
  }

  set poolName(value: string) {
    this.set("poolName", Value.fromString(value));
  }

  get managerName(): string {
    let value = this.get("managerName");
    return value!.toString();
  }

  set managerName(value: string) {
    this.set("managerName", Value.fromString(value));
  }

  get manager(): Bytes | null {
    let value = this.get("manager");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set manager(value: Bytes | null) {
    if (!value) {
      this.unset("manager");
    } else {
      this.set("manager", Value.fromBytes(<Bytes>value));
    }
  }

  get uniqueInvestor(): string {
    let value = this.get("uniqueInvestor");
    return value!.toString();
  }

  set uniqueInvestor(value: string) {
    this.set("uniqueInvestor", Value.fromString(value));
  }
}

export class ManagerFeeMinted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ManagerFeeMinted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ManagerFeeMinted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ManagerFeeMinted", id.toString(), this);
    }
  }

  static load(id: string): ManagerFeeMinted | null {
    return changetype<ManagerFeeMinted | null>(
      store.get("ManagerFeeMinted", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): Bytes {
    let value = this.get("pool");
    return value!.toBytes();
  }

  set pool(value: Bytes) {
    this.set("pool", Value.fromBytes(value));
  }

  get manager(): Bytes {
    let value = this.get("manager");
    return value!.toBytes();
  }

  set manager(value: Bytes) {
    this.set("manager", Value.fromBytes(value));
  }

  get available(): BigInt {
    let value = this.get("available");
    return value!.toBigInt();
  }

  set available(value: BigInt) {
    this.set("available", Value.fromBigInt(value));
  }

  get daoFee(): BigInt {
    let value = this.get("daoFee");
    return value!.toBigInt();
  }

  set daoFee(value: BigInt) {
    this.set("daoFee", Value.fromBigInt(value));
  }

  get managerFee(): BigInt {
    let value = this.get("managerFee");
    return value!.toBigInt();
  }

  set managerFee(value: BigInt) {
    this.set("managerFee", Value.fromBigInt(value));
  }

  get tokenPriceAtLastFeeMint(): BigInt {
    let value = this.get("tokenPriceAtLastFeeMint");
    return value!.toBigInt();
  }

  set tokenPriceAtLastFeeMint(value: BigInt) {
    this.set("tokenPriceAtLastFeeMint", Value.fromBigInt(value));
  }

  get block(): i32 {
    let value = this.get("block");
    return value!.toI32();
  }

  set block(value: i32) {
    this.set("block", Value.fromI32(value));
  }
}

export class PoolManagerLogicSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PoolManagerLogicSet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PoolManagerLogicSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PoolManagerLogicSet", id.toString(), this);
    }
  }

  static load(id: string): PoolManagerLogicSet | null {
    return changetype<PoolManagerLogicSet | null>(
      store.get("PoolManagerLogicSet", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get poolManagerLogic(): Bytes {
    let value = this.get("poolManagerLogic");
    return value!.toBytes();
  }

  set poolManagerLogic(value: Bytes) {
    this.set("poolManagerLogic", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }
}

export class PoolPrivacyUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PoolPrivacyUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PoolPrivacyUpdated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PoolPrivacyUpdated", id.toString(), this);
    }
  }

  static load(id: string): PoolPrivacyUpdated | null {
    return changetype<PoolPrivacyUpdated | null>(
      store.get("PoolPrivacyUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get isPoolPrivate(): boolean {
    let value = this.get("isPoolPrivate");
    return value!.toBoolean();
  }

  set isPoolPrivate(value: boolean) {
    this.set("isPoolPrivate", Value.fromBoolean(value));
  }
}

export class TransactionExecuted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TransactionExecuted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TransactionExecuted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TransactionExecuted", id.toString(), this);
    }
  }

  static load(id: string): TransactionExecuted | null {
    return changetype<TransactionExecuted | null>(
      store.get("TransactionExecuted", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): Bytes {
    let value = this.get("pool");
    return value!.toBytes();
  }

  set pool(value: Bytes) {
    this.set("pool", Value.fromBytes(value));
  }

  get manager(): Bytes {
    let value = this.get("manager");
    return value!.toBytes();
  }

  set manager(value: Bytes) {
    this.set("manager", Value.fromBytes(value));
  }

  get transactionType(): i32 {
    let value = this.get("transactionType");
    return value!.toI32();
  }

  set transactionType(value: i32) {
    this.set("transactionType", Value.fromI32(value));
  }

  get time(): BigInt {
    let value = this.get("time");
    return value!.toBigInt();
  }

  set time(value: BigInt) {
    this.set("time", Value.fromBigInt(value));
  }

  get blockNumber(): i32 {
    let value = this.get("blockNumber");
    return value!.toI32();
  }

  set blockNumber(value: i32) {
    this.set("blockNumber", Value.fromI32(value));
  }

  get poolName(): string {
    let value = this.get("poolName");
    return value!.toString();
  }

  set poolName(value: string) {
    this.set("poolName", Value.fromString(value));
  }

  get managerName(): string {
    let value = this.get("managerName");
    return value!.toString();
  }

  set managerName(value: string) {
    this.set("managerName", Value.fromString(value));
  }
}

export class Transfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Transfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Transfer", id.toString(), this);
    }
  }

  static load(id: string): Transfer | null {
    return changetype<Transfer | null>(store.get("Transfer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get address(): string {
    let value = this.get("address");
    return value!.toString();
  }

  set address(value: string) {
    this.set("address", Value.fromString(value));
  }

  get block(): i32 {
    let value = this.get("block");
    return value!.toI32();
  }

  set block(value: i32) {
    this.set("block", Value.fromI32(value));
  }
}

export class Withdrawal extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Withdrawal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Withdrawal must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Withdrawal", id.toString(), this);
    }
  }

  static load(id: string): Withdrawal | null {
    return changetype<Withdrawal | null>(store.get("Withdrawal", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fundAddress(): Bytes {
    let value = this.get("fundAddress");
    return value!.toBytes();
  }

  set fundAddress(value: Bytes) {
    this.set("fundAddress", Value.fromBytes(value));
  }

  get investor(): Bytes {
    let value = this.get("investor");
    return value!.toBytes();
  }

  set investor(value: Bytes) {
    this.set("investor", Value.fromBytes(value));
  }

  get valueWithdrawn(): BigInt {
    let value = this.get("valueWithdrawn");
    return value!.toBigInt();
  }

  set valueWithdrawn(value: BigInt) {
    this.set("valueWithdrawn", Value.fromBigInt(value));
  }

  get fundTokensWithdrawn(): BigInt {
    let value = this.get("fundTokensWithdrawn");
    return value!.toBigInt();
  }

  set fundTokensWithdrawn(value: BigInt) {
    this.set("fundTokensWithdrawn", Value.fromBigInt(value));
  }

  get totalInvestorFundTokens(): BigInt {
    let value = this.get("totalInvestorFundTokens");
    return value!.toBigInt();
  }

  set totalInvestorFundTokens(value: BigInt) {
    this.set("totalInvestorFundTokens", Value.fromBigInt(value));
  }

  get fundValue(): BigInt {
    let value = this.get("fundValue");
    return value!.toBigInt();
  }

  set fundValue(value: BigInt) {
    this.set("fundValue", Value.fromBigInt(value));
  }

  get time(): BigInt {
    let value = this.get("time");
    return value!.toBigInt();
  }

  set time(value: BigInt) {
    this.set("time", Value.fromBigInt(value));
  }

  get block(): i32 {
    let value = this.get("block");
    return value!.toI32();
  }

  set block(value: i32) {
    this.set("block", Value.fromI32(value));
  }

  get totalSupply(): BigDecimal {
    let value = this.get("totalSupply");
    return value!.toBigDecimal();
  }

  set totalSupply(value: BigDecimal) {
    this.set("totalSupply", Value.fromBigDecimal(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get poolName(): string {
    let value = this.get("poolName");
    return value!.toString();
  }

  set poolName(value: string) {
    this.set("poolName", Value.fromString(value));
  }

  get uniqueInvestor(): string {
    let value = this.get("uniqueInvestor");
    return value!.toString();
  }

  set uniqueInvestor(value: string) {
    this.set("uniqueInvestor", Value.fromString(value));
  }

  get managerName(): string {
    let value = this.get("managerName");
    return value!.toString();
  }

  set managerName(value: string) {
    this.set("managerName", Value.fromString(value));
  }
}

export class Pool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Pool entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Pool must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Pool", id.toString(), this);
    }
  }

  static load(id: string): Pool | null {
    return changetype<Pool | null>(store.get("Pool", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fundAddress(): Bytes {
    let value = this.get("fundAddress");
    return value!.toBytes();
  }

  set fundAddress(value: Bytes) {
    this.set("fundAddress", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get manager(): Bytes | null {
    let value = this.get("manager");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set manager(value: Bytes | null) {
    if (!value) {
      this.unset("manager");
    } else {
      this.set("manager", Value.fromBytes(<Bytes>value));
    }
  }

  get managerName(): string {
    let value = this.get("managerName");
    return value!.toString();
  }

  set managerName(value: string) {
    this.set("managerName", Value.fromString(value));
  }

  get totalSupply(): BigDecimal {
    let value = this.get("totalSupply");
    return value!.toBigDecimal();
  }

  set totalSupply(value: BigDecimal) {
    this.set("totalSupply", Value.fromBigDecimal(value));
  }

  get tokenPrice(): BigInt {
    let value = this.get("tokenPrice");
    return value!.toBigInt();
  }

  set tokenPrice(value: BigInt) {
    this.set("tokenPrice", Value.fromBigInt(value));
  }

  get decimals(): BigInt | null {
    let value = this.get("decimals");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set decimals(value: BigInt | null) {
    if (!value) {
      this.unset("decimals");
    } else {
      this.set("decimals", Value.fromBigInt(<BigInt>value));
    }
  }

  get deposits(): Array<string> {
    let value = this.get("deposits");
    return value!.toStringArray();
  }

  set deposits(value: Array<string>) {
    this.set("deposits", Value.fromStringArray(value));
  }

  get withdrawals(): Array<string> {
    let value = this.get("withdrawals");
    return value!.toStringArray();
  }

  set withdrawals(value: Array<string>) {
    this.set("withdrawals", Value.fromStringArray(value));
  }
}

export class Manager extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Manager entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Manager must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Manager", id.toString(), this);
    }
  }

  static load(id: string): Manager | null {
    return changetype<Manager | null>(store.get("Manager", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get managerAddress(): Bytes {
    let value = this.get("managerAddress");
    return value!.toBytes();
  }

  set managerAddress(value: Bytes) {
    this.set("managerAddress", Value.fromBytes(value));
  }

  get fundCreated(): Array<string> {
    let value = this.get("fundCreated");
    return value!.toStringArray();
  }

  set fundCreated(value: Array<string>) {
    this.set("fundCreated", Value.fromStringArray(value));
  }
}

export class Investor extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Investor entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Investor must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Investor", id.toString(), this);
    }
  }

  static load(id: string): Investor | null {
    return changetype<Investor | null>(store.get("Investor", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get investorAddress(): Bytes {
    let value = this.get("investorAddress");
    return value!.toBytes();
  }

  set investorAddress(value: Bytes) {
    this.set("investorAddress", Value.fromBytes(value));
  }

  get deposits(): Array<string> {
    let value = this.get("deposits");
    return value!.toStringArray();
  }

  set deposits(value: Array<string>) {
    this.set("deposits", Value.fromStringArray(value));
  }

  get withdrawals(): Array<string> {
    let value = this.get("withdrawals");
    return value!.toStringArray();
  }

  set withdrawals(value: Array<string>) {
    this.set("withdrawals", Value.fromStringArray(value));
  }
}

export class ExchangeFrom extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExchangeFrom entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExchangeFrom must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExchangeFrom", id.toString(), this);
    }
  }

  static load(id: string): ExchangeFrom | null {
    return changetype<ExchangeFrom | null>(store.get("ExchangeFrom", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fundAddress(): Bytes {
    let value = this.get("fundAddress");
    return value!.toBytes();
  }

  set fundAddress(value: Bytes) {
    this.set("fundAddress", Value.fromBytes(value));
  }

  get sourceAsset(): Bytes {
    let value = this.get("sourceAsset");
    return value!.toBytes();
  }

  set sourceAsset(value: Bytes) {
    this.set("sourceAsset", Value.fromBytes(value));
  }

  get sourceAmount(): BigInt {
    let value = this.get("sourceAmount");
    return value!.toBigInt();
  }

  set sourceAmount(value: BigInt) {
    this.set("sourceAmount", Value.fromBigInt(value));
  }

  get dstAsset(): Bytes {
    let value = this.get("dstAsset");
    return value!.toBytes();
  }

  set dstAsset(value: Bytes) {
    this.set("dstAsset", Value.fromBytes(value));
  }

  get time(): BigInt {
    let value = this.get("time");
    return value!.toBigInt();
  }

  set time(value: BigInt) {
    this.set("time", Value.fromBigInt(value));
  }
}

export class ExchangeTo extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExchangeTo entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExchangeTo must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExchangeTo", id.toString(), this);
    }
  }

  static load(id: string): ExchangeTo | null {
    return changetype<ExchangeTo | null>(store.get("ExchangeTo", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fundAddress(): Bytes {
    let value = this.get("fundAddress");
    return value!.toBytes();
  }

  set fundAddress(value: Bytes) {
    this.set("fundAddress", Value.fromBytes(value));
  }

  get sourceAsset(): Bytes {
    let value = this.get("sourceAsset");
    return value!.toBytes();
  }

  set sourceAsset(value: Bytes) {
    this.set("sourceAsset", Value.fromBytes(value));
  }

  get dstAsset(): Bytes {
    let value = this.get("dstAsset");
    return value!.toBytes();
  }

  set dstAsset(value: Bytes) {
    this.set("dstAsset", Value.fromBytes(value));
  }

  get dstAmount(): BigInt {
    let value = this.get("dstAmount");
    return value!.toBigInt();
  }

  set dstAmount(value: BigInt) {
    this.set("dstAmount", Value.fromBigInt(value));
  }

  get time(): BigInt {
    let value = this.get("time");
    return value!.toBigInt();
  }

  set time(value: BigInt) {
    this.set("time", Value.fromBigInt(value));
  }
}
